"""Wall class"""
import numpy as np

from building3d import random_id
from building3d.geom.point import Point
from building3d.geom.polygon import Polygon
from building3d.geom.exceptions import GeometryError


class Wall:
    """A wall is a collection of polygons with additional attributes and methods.

    Polygons do not have to be coplanar.
    Polygons can have subpolygons (e.g. a wall with a window).

    Wall is used to model 1D phenomena (e.g. heat transfer).
    """
    def __init__(self, polygons: list[Polygon] = [], name: str | None = None):
        if name is None:
            name = random_id()

        self.name = name
        self.polygons: dict[str, Polygon] = {}  # Dict of polygons and subpolygons
        self.polygraph: dict[str, list[str]] = {}  # Graph with parent and subpolygons

        for poly in polygons:
            self.add_polygon(poly)

    def get_parent_names(self) -> list[str]:
        return list(self.polygraph.keys())

    def get_polygons(self, only_parents=True) -> list[Polygon]:
        if only_parents:
            return [self.polygons[name] for name in self.get_parent_names()]
        else:
            return list(self.polygons.values())

    def get_subpolygons(self, parent: str) -> list[Polygon]:
        if parent in self.polygraph.keys():
            return [self.polygons[name] for name in self.polygraph[parent]]
        else:
            return []

    def add_polygon(self, poly: Polygon, parent: str | None = None):
        """Add polygon to the wall.

        A polygon can be a top-level (parent) polygon or a subpolygon.
        Only 1 level of subpolygons is allowed, i.e. a polygon cannot be
        a subpolygon to another subpolygon.

        A subpolygon must be entirely inside its parent polygon.

        Args:
            poly: polygon to be added
            parent: name of parent polygon if this is a subpolygon (default None)
        """
        self.polygons[poly.name] = poly
        if parent is None:
            # This might be a parent polygon
            self.polygraph[poly.name] = []
        else:
            # Add this polygon to its parent
            self.polygraph[parent].append(poly.name)

            # Assert polygon is inside parent polygon
            for p in poly.points:
                if not self.polygons[parent].is_point_inside(p):
                    raise GeometryError(f"Polygon {poly.name} is not entirely inside {parent}")

    def get_mesh(
        self,
        only_parents: bool = True,
    ) -> tuple[list[Point], list[tuple[int, ...]]]:
        """Get vertices and faces of this wall's polygons.

        This function returns faces generated by the ear-clipping algorithm.
        """
        verts = []
        faces = []

        for poly in self.get_polygons(only_parents=only_parents):
            offset = len(verts)
            verts.extend(poly.points)
            f = np.array(poly.triangles) + offset
            f = [tuple(x) for x in f]
            faces.extend(f)

        return verts, faces

    def __eq__(self, other):
        """Return True if all polygons of this and other are equal."""
        if len(self.polygons.values()) != len(other.polygons.values()):
            return False
        else:
            num_matches = 0
            for this_poly in self.polygons.values():
                for other_poly in other.polygons.values():
                    if this_poly == other_poly:
                        num_matches += 1
                        break
            if num_matches != len(self.polygons.values()):
                return False
        return True

