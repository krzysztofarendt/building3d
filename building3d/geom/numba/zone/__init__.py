import logging
from typing import Sequence

from building3d import random_id
from building3d.geom.paths.validate_name import validate_name
from building3d.geom.numba.points import bounding_box
from building3d.geom.numba.types import PointType, IndexType
from building3d.geom.numba.solid import Solid
from building3d.geom.numba.wall import Wall
from building3d.geom.numba.polygon import Polygon
from building3d.geom.numba.zone.get_mesh import get_mesh_from_solids
from building3d.geom.exceptions import GeometryError


logger = logging.getLogger(__name__)


class Zone:
    """Zone is a collection of solids with additional attributes and methods.

    Solids must be adjacent. (TODO: I think, this is not checked at the moment)

    Zone is used to model 3D phenomena (e.g. ray tracing, heat transfer, CFD).
    """
    def __init__(
        self,
        solids: Sequence[Solid] = (),
        name: str | None = None,
        uid: str | None = None,
    ):
        """Initialize the zone.

        Args:
            solids: list of Solid instances
            name: name of the zone
            uid: unique id of the zone, random if None
        """
        if name is None:
            name = random_id()
        self.name = validate_name(name)
        if uid is not None:
            self.uid = uid
        else:
            self.uid = random_id()
        self.solids: dict[str, Solid] = {}  # {Solid.name: Solid}

        for sld in solids:
            self.add_solid(sld)

        logger.info(f"Zone created: {self}")

    def add_solid(self, sld: Solid) -> None:
        """Add a Solid instance to the zone.

        Args:
            sld: solid to be added
        """
        # Check if it is adjacent to existing solids
        if len(self.solids) > 1:
            adjacent = False
            for _, existing_sld in self.solids.items():
                if sld.is_adjacent_to_solid(existing_sld, exact=False):
                    adjacent = True
            if not adjacent:
                raise GeometryError(
                    f"Cannot add solid {sld.name}, because it is disconnected "
                    f"from other solids in this zone: {self.solids.keys}"
                )

        # Add solid
        self.solids[sld.name] = sld

        logger.info(f"Solid {sld.name} added: {self}")

    def get_solid_names(self) -> list[str]:
        """Get list of solid names."""
        return list(self.solids.keys())

    def get_solids(self) -> list[Solid]:
        """Get list of solids."""
        return list(self.solids.values())

    def get_object(self, path: str) -> Solid | Wall | Polygon:
        """Get object by the path. The path contains names of nested components."""
        names = path.split("/")
        solid_name = names.pop(0)

        if solid_name not in self.get_solid_names():
            raise ValueError(f"Solid not found: {solid_name}")
        elif len(names) == 0:
            return self.solids[solid_name]
        else:
            return self.solids[solid_name].get_object("/".join(names))

    def bbox(self) -> tuple[PointType, PointType]:
        pts, _ = self.get_mesh()
        return bounding_box(pts)

    def get_mesh(self) -> tuple[PointType, IndexType]:
        """Get vertices and faces of all solids. Used mostly for plotting.

        This function returns faces generated by the ear-clipping algorithm.

        Return:
            tuple of vertices, shaped (num_pts, 3), and faces, shaped (num_tri, 3)
        """
        return get_mesh_from_solids(self.get_solids())

    def volume(self) -> float:
        """Calculate zone volume as the sum of solid volumes."""
        volume = 0.0
        for sld in self.solids.values():
            volume += sld.volume
        return volume

    def __str__(self):
        s = f"Zone(name={self.name}, "
        s += f"solids={self.get_solid_names()}, "
        s += f"id={hex(id(self))})"
        return s

    def __repr__(self):
        return self.__str__()
