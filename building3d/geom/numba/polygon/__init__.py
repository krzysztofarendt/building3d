import logging

import numpy as np

from building3d import random_id
from building3d.config import GEOM_ATOL
from building3d.geom.paths.validate_name import validate_name
from building3d.geom.numba.types import PointType, VectorType, IndexType, FLOAT
from building3d.geom.numba.points import are_points_coplanar
from building3d.geom.numba.points import bounding_box
from building3d.geom.numba.points import new_point_between_2_points
from building3d.geom.numba.polygon.ispointinside import is_point_at_boundary
from building3d.geom.numba.vectors import normal
from building3d.geom.numba.triangles import triangulate
from building3d.geom.numba.triangles import triangle_centroid
from building3d.geom.numba.polygon.centroid import polygon_centroid
from building3d.geom.numba.polygon.area import polygon_area
from building3d.geom.numba.polygon.plane import plane_coefficients
from building3d.geom.numba.polygon.ispointinside import is_point_inside, is_point_inside_margin
from building3d.geom.numba.polygon.polygonsfacing import are_polygons_facing


logger = logging.getLogger(__name__)


class Polygon:
    def __init__(
        self,
        pts: PointType,
        name: str | None = None,
        uid: str | None = None,
        tri: IndexType | None = None,
    ):
        # Sanity checks
        assert are_points_coplanar(pts), "Polygon points must be coplanar"
        assert len(pts) >= 3, "Polygon needs at least 3 points"

        # Attribute assignment
        if name is None:
            name = random_id()
        self.name: str = validate_name(name)

        self.uid: str = ""
        if uid is None:
            self.uid = random_id()
        else:
            self.uid = uid

        self.pts: PointType = pts
        self.vn: VectorType = normal(self.pts[-1], self.pts[0], self.pts[1])

        if tri is None:
            self.tri: IndexType = triangulate(self.pts, self.vn)
        else:
            assert len(tri) > 0, "Empty triangles provided"
            self.tri: IndexType = tri

        self.ctr: PointType = polygon_centroid(self.pts, self.tri)
        self.area: float = polygon_area(self.pts, self.vn)
        self.plane_coefficients: tuple[FLOAT, FLOAT, FLOAT, FLOAT] = plane_coefficients(self.pts)

    def bbox(self) -> tuple[PointType, PointType]:
        return bounding_box(self.pts)

    def get_mesh(self) -> tuple[PointType, IndexType]:
        """Get vertices and faces of this polygon.

        This function returns faces generated by the ear-clipping algorithm.

        Return:
            tuple of vertices, shaped (num_pts, 3), and faces, shaped (num_tri, 3)
        """
        return self.pts, self.tri

    def flip(self, new_name: str | None = None):
        """Copies and flips the polygon. Changes the name.

        Args:
            new_name: polygon name (must be unique within a Wall)

        Returns:
            Polygon
        """
        return Polygon(self.pts[::-1].copy(), name=new_name)

    def get_some_interior_point(self) -> PointType:
        """Return some point laying inside this polygon.

        Such point is sometimes needed to distuingish inside from outside.
        """
        pt1 = self.pts[self.tri[0, 0]]
        pt2 = self.pts[self.tri[0, 1]]
        pt3 = self.pts[self.tri[0, 2]]
        some_pt = triangle_centroid(pt1, pt2, pt3)
        return some_pt

    def is_point_inside(self, pt: PointType, boundary_in: bool = True) -> bool:
        return is_point_inside(pt, self.pts, self.tri, boundary_in)

    def is_facing_polygon(self, other, exact: bool = True) -> bool:
        return are_polygons_facing(
            self.pts, self.tri, self.vn, other.pts, other.tri, other.vn, exact
        )

    def contains_polygon(self, other) -> bool:
        """Checks if the other polygon is completely inside this one.
        """
        for pt in other.pts:
            if not is_point_inside_margin(pt, GEOM_ATOL, self.pts, self.tri):
                return False
        return True

    def is_touching_polygon(self, other) -> bool:
        """Checks if the polygon touches (but doesn't cross) another one.
        """
        at_least_one_boundary = False
        edge = [other.pts[-1]]
        middle_pt = None

        for ptest in other.pts:
            edge.append(ptest)
            middle_pt = new_point_between_2_points(edge[0], edge[1], rel_d=0.5)
            edge.pop(0)

            at_boundary = is_point_at_boundary(ptest, self.pts)
            is_inside = self.is_point_inside(ptest, boundary_in=False)
            is_middle_inside = self.is_point_inside(middle_pt, boundary_in=False)

            if is_middle_inside:
                return False
            if is_inside:
                return False
            if at_boundary:
                at_least_one_boundary = True

        is_touching = True if at_least_one_boundary else False

        return is_touching

    def __eq__(self, other):
        if np.allclose(self.pts, other.pts):
            return True
        else:
            return False

    def __str__(self):
        return f"Polygon(name={self.name}, pts.shape={self.pts.shape}, id={hex(id(self))})"

    def __repr__(self):
        return self.__str__()
