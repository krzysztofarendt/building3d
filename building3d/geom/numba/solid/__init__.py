import logging
from typing import Sequence

import numpy as np

from building3d import random_id
from building3d.geom.paths.object_path import object_path
from building3d.geom.paths.validate_name import validate_name
from building3d.geom.exceptions import GeometryError
from building3d.geom.numba.wall import Wall
from building3d.geom.numba.types import PointType, IndexType
from building3d.geom.numba.points import new_point
from building3d.geom.numba.polygon import Polygon
from building3d.geom.numba.polygon.ispointinside import is_point_inside_projection
from building3d.geom.numba.polygon.polygonsfacing import are_polygons_facing
from building3d.geom.numba.tetrahedrons import tetrahedron_volume


logger = logging.getLogger(__name__)


class Solid:
    """Solid is a space enclosed by polygons."""
    def __init__(
        self,
        walls: Sequence[Wall] = [],
        name: str | None = None,
        uid: str | None = None,
    ):
        """Initialize the solid

        Args:
            walls: list of Wall instances
            name: name of the solid
            uid: unique id of the solid, random if None
        """
        if name is None:
            name = random_id()
        self.name = validate_name(name)
        if uid is not None:
            self.uid = uid
        else:
            self.uid = random_id()
        self.walls: dict[str, Wall] = {}  # {Wall.name: Wall}
        for w in walls:
            self.add_wall(w)
        self.volume = self._volume()

    def add_wall(self, wall: Wall) -> None:
        """Add a Wall instance to the solid."""
        self.walls[wall.name] = wall

    def get_wall_names(self) -> list[str]:
        """Get list of wall names."""
        return list(self.walls.keys())

    def get_walls(self) -> list[Wall]:
        """Get list of walls."""
        return list(self.walls.values())

    def get_polygons(self) -> list[Polygon]:
        """Return list with all polygons of this solid."""
        poly = []
        for wall in self.get_walls():
            poly.extend(wall.get_polygons())
        return poly

    def find_polygon(self, poly_name: str) -> str:
        """Find polygon by name. Return path suitable for get_object(). Will search in all walls."""
        for wall in self.get_walls():
            for poly in wall.get_polygons():
                if poly.name == poly_name:
                    return object_path(wall=wall, poly=poly)
        raise GeometryError(f"Polygon {poly_name} not found")

    def get_object(self, path: str) -> Wall | Polygon | None:
        """Get object by the path. The path contains names of nested components."""
        names = path.split("/")
        wall_name = names.pop(0)

        if wall_name not in self.get_wall_names():
            raise ValueError(f"Wall not found: {wall_name}")
        elif len(names) == 0:
            return self.walls[wall_name]
        else:
            return self.walls[wall_name].get_object("/".join(names))

    def get_mesh(self) -> tuple[PointType, IndexType]:
        """Get vertices and faces of this solid's polygons.

        This function returns faces generated by the ear-clipping algorithm.

        Return:
            tuple of vertices and faces
        """
        verts = []
        faces = []

        for w in self.walls.values():
            offset = len(verts)
            v, f = w.get_mesh()
            verts.extend(v.tolist())
            f += offset
            faces.extend(f.tolist())

        verts_arr = np.vstack(verts)
        faces_arr = np.array(faces)

        return verts_arr, faces_arr

    def bounding_box(self) -> PointType:
        """Return array [[xmin, ymin, zmin], [xmax, ymax, zmax]]"""
        vertices, _ = self.get_mesh()
        xaxis = vertices[:, 0]
        yaxis = vertices[:, 1]
        zaxis = vertices[:, 2]
        pmin = new_point(xaxis.min(), yaxis.min(), zaxis.min())
        pmax = new_point(xaxis.max(), yaxis.max(), zaxis.max())
        return np.vstack((pmin, pmax))

    def is_point_inside(self, pt: PointType) -> bool:
        """Checks whether the point p is inside the solid.

        Being at the boundary is assumed to be inside.

        Uses the ray casting algorithm:
        draw a horizontal line in a chosen direction from the point
        and count how many times it intersects with the edges of the
        solid; if the number of intersections is odd, it is inside.
        """
        vertices, _ = self.get_mesh()
        max_x = vertices[:, 0].max()
        max_y = vertices[:, 1].max()
        max_z = vertices[:, 2].max()
        min_x = vertices[:, 0].min()
        min_y = vertices[:, 1].min()
        min_z = vertices[:, 2].min()

        # Check if it is possible that the point is inside the solid
        if pt[0] > max_x or pt[1] > max_y or pt[2] > max_z:
            return False
        if pt[0] < min_x or pt[1] < min_y or pt[2] < min_z:
            return False

        # It is possible, so we proceed with the ray casting algorithm
        # This algorithm may give wrong answer if the point lays in the corner
        vec = np.array([0.739, 0.239, 0.113])  # Just a random vector
        vec /= np.linalg.norm(vec)

        num_crossings = 0
        for poly in self.get_polygons():
            p_crosses_polygon = is_point_inside_projection(pt, vec, poly.pts, poly.tri)
            if p_crosses_polygon:
                num_crossings += 1

        if num_crossings % 2 == 1:
            return True
        else:
            # Check if point is at the boundary
            if self.is_point_at_the_boundary(pt):
                return True
            else:
                return False

    def is_point_at_the_boundary(self, pt: PointType) -> bool:
        """Checks whether the point p lays on any of the boundary polygons."""
        for poly in self.get_polygons():
            if poly.is_point_inside(pt):
                return True
        return False

    def is_adjacent_to_solid(self, sld, exact: bool = True) -> bool:
        """Checks if this solid is adjacent to another solid.

        The argument `exact` has the same meaning as in Polygon.is_facing_polygon().
        If `exact` is True, all points of adjacent polygons must be equal.
        If `exact` is False, the method checks only in points are coplanar and
        normal vectors are opposite.

        Args:
            sld: other solid
            exact: if True, the solid must be exactly adjacent

        Return:
            True if the solids are adjacent
        """
        # TODO: Polygons can be sorted based on the distance of their centroids
        for this_poly in self.get_polygons():
            for other_poly in sld.get_polygons():
                pts1 = this_poly.pts
                tri1 = this_poly.tri
                vn1 = this_poly.vn
                pts2 = other_poly.pts
                tri2 = other_poly.tri
                vn2 = other_poly.vn
                if are_polygons_facing(pts1, tri1, vn1, pts2, tri2, vn2, exact=exact):
                    return True
        return False

    def _volume(self) -> float:
        """Based on: http://chenlab.ece.cornell.edu/Publication/Cha/icip01_Cha.pdf"""
        total_volume = 0.0
        for poly in self.get_polygons():
            for tri in poly.tri:
                p0 = new_point(0.0, 0.0, 0.0)
                p1 = poly.pts[tri[0]]
                p2 = poly.pts[tri[1]]
                p3 = poly.pts[tri[2]]
                v = tetrahedron_volume(p0, p1, p2, p3)

                pos_wrt_origin = np.dot(poly.vn, p1 - p0)
                if pos_wrt_origin == 0.0:
                    pos_wrt_origin = np.dot(poly.vn, p2 - p0)

                if pos_wrt_origin > 0:
                    sign = 1.0
                else:
                    sign = -1.0

                total_volume += sign * v

        return abs(float(total_volume))

    def __str__(self):
        return f"Solid({self.name=}, {self.walls=}, id={hex(id(self))})"

    def __eq__(self, other):
        """Return True if all walls of this and other are equal."""
        if len(self.walls) != len(other.walls):
            return False
        else:
            num_matches = 0
            for this_wall in self.walls.values():
                for other_wall in other.walls.values():
                    if this_wall == other_wall:
                        num_matches += 1
                        break
            if num_matches != len(self.walls):
                return False
        return True
