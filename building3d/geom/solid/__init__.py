import logging
from typing import Sequence

import numpy as np

from building3d import random_id
from building3d.geom.paths import PATH_SEP
from building3d.geom.exceptions import GeometryError
from building3d.geom.paths.validate_name import validate_name
from building3d.geom.wall import Wall
from building3d.geom.types import PointType, IndexType
from building3d.geom.points import bounding_box
from building3d.geom.points import new_point
from building3d.geom.polygon.ispointinside import is_point_inside_projection
from building3d.geom.polygon.crossing import are_polygons_crossing
from building3d.geom.polygon.facing import are_polygons_facing
from building3d.geom.tetrahedrons import tetrahedron_volume
from building3d.geom.solid.get_mesh import get_mesh_from_walls


logger = logging.getLogger(__name__)


class Solid:
    """Solid is a space enclosed by polygons."""

    count: int = 0

    def __init__(
        self,
        walls: Sequence[Wall] = (),
        name: str | None = None,
        uid: str | None = None,
        parent=None,
    ):
        """Initialize the solid

        Args:
            walls: list of Wall instances
            name: name of the solid
            uid: unique id of the solid, random if None
        """
        self._parent = parent

        if name is None:
            name = random_id()
        self.name = validate_name(name)
        if uid is not None:
            self.uid = uid
        else:
            self.uid = random_id()
        self.walls: dict[str, Wall] = {}  # {Wall.name: Wall}
        for w in walls:
            self.add_wall(w)

        self.num = Solid.count
        Solid.count += 1

    @property
    def children(self) -> dict[str, Wall]:
        return self.walls

    @property
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, zone):
        self._parent = zone

    @property
    def path(self) -> str:
        if self.parent is not None:
            p = PATH_SEP.join([self.parent.path, self.name])
            return p
        else:
            return self.name

    def add_wall(self, wall: Wall) -> None:
        """Add a Wall instance to the solid."""
        if wall.name in self.children.keys():
            raise GeometryError(f"Wall {wall.name} already exists in {self.name}")

        wall.parent = self
        self.walls[wall.name] = wall

    def replace_wall(self, old_name: str, new_wall: Wall):
        del self.walls[old_name]
        self.add_wall(new_wall)

    def get(self, abspath: str):
        """Get object by the absolute path."""
        obj = self
        while obj.parent is not None:
            obj = obj.parent
        building = obj
        return building.get(abspath)

    def get_mesh(self) -> tuple[PointType, IndexType]:
        """Get vertices and faces of this solid's walls.

        This function returns faces generated by the ear-clipping algorithm.

        Return:
            tuple of vertices, shaped (num_pts, 3), and faces, shaped (num_tri, 3)
        """
        return get_mesh_from_walls(list(self.children.values()))

    def bbox(self) -> tuple[PointType, PointType]:
        pts, _ = self.get_mesh()
        return bounding_box(pts)

    def is_point_inside(self, pt: PointType) -> bool:  # TODO: use numba
        """Checks whether the point p is inside the solid.

        Being at the boundary is assumed to be inside.

        Uses the ray casting algorithm:
        draw a horizontal line in a chosen direction from the point
        and count how many times it intersects with the edges of the
        solid; if the number of intersections is odd, it is inside.
        """
        bbox = self.bbox()
        min_x, min_y, min_z = bbox[0]
        max_x, max_y, max_z = bbox[1]

        # Check if it is possible that the point is inside the solid
        if pt[0] > max_x or pt[1] > max_y or pt[2] > max_z:
            return False
        if pt[0] < min_x or pt[1] < min_y or pt[2] < min_z:
            return False

        # It is possible, so we proceed with the ray casting algorithm
        # This algorithm may give wrong answer if the point lays in the corner
        vec = np.array([0.739, 0.239, 0.113])  # Just a random vector
        vec /= np.linalg.norm(vec)

        num_crossings = 0
        all_polys = [p for w in self.children.values() for p in w.children.values()]
        for poly in all_polys:
            p_crosses_polygon = is_point_inside_projection(pt, vec, poly.pts, poly.tri)
            if p_crosses_polygon:
                num_crossings += 1

        if num_crossings % 2 == 1:
            return True
        else:
            # Check if point is at the boundary
            if self.is_point_at_boundary(pt):
                return True
            else:
                return False

    def is_point_at_boundary(self, pt: PointType) -> bool:
        """Checks whether the point p lays on any of the boundary polygons."""
        all_polys = [p for w in self.children.values() for p in w.children.values()]
        for poly in all_polys:
            if poly.is_point_inside(pt):
                return True
        return False

    def is_adjacent_to_solid(self, sld) -> bool:
        """Checks if this solid is adjacent to another solid.

        Args:
            sld: other solid

        Return:
            True if the solids are adjacent
        """
        # TODO: Polygons can be sorted based on the distance of their centroids
        this_all_polys = [
            p for w in self.children.values() for p in w.children.values()
        ]
        other_all_polys = [
            p for w in sld.children.values() for p in w.children.values()
        ]

        for this_poly in this_all_polys:
            for other_poly in other_all_polys:
                pts1 = this_poly.pts
                tri1 = this_poly.tri
                vn1 = this_poly.vn
                pts2 = other_poly.pts
                tri2 = other_poly.tri
                vn2 = other_poly.vn
                if are_polygons_crossing(pts1, tri1, pts2, tri2):
                    return True
                elif are_polygons_facing(pts1, vn1, pts2, vn2):
                    return True
        return False

    @property
    def volume(self) -> float:
        """Based on: http://chenlab.ece.cornell.edu/Publication/Cha/icip01_Cha.pdf"""
        total_volume = 0.0
        all_polys = [p for w in self.children.values() for p in w.children.values()]
        for poly in all_polys:
            for tri in poly.tri:
                p0 = new_point(0.0, 0.0, 0.0)
                p1 = poly.pts[tri[0]]
                p2 = poly.pts[tri[1]]
                p3 = poly.pts[tri[2]]
                v = tetrahedron_volume(p0, p1, p2, p3)

                pos_wrt_origin = np.dot(poly.vn, p1 - p0)
                if pos_wrt_origin == 0.0:
                    pos_wrt_origin = np.dot(poly.vn, p2 - p0)

                if pos_wrt_origin > 0:
                    sign = 1.0
                else:
                    sign = -1.0

                total_volume += sign * v

        return abs(float(total_volume))

    def __str__(self):
        return f"Solid(name={self.name}, walls={list(self.children.keys())}, id={hex(id(self))})"

    def __repr__(self):
        return self.__str__()

    def __getitem__(self, key) -> Wall:
        return self.walls[key]
