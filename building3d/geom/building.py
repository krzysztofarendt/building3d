"""Building class"""
from __future__ import annotations

import numpy as np

from building3d import random_id
from building3d import validate_name
from building3d.geom.point import Point
from building3d.geom.zone import Zone
from building3d.geom.solid import Solid
from building3d.geom.wall import Wall
from building3d.geom.polygon import Polygon
import building3d.mesh.mesh as mesh
from building3d.config import MESH_DELTA


class Building:
    """Building is a collection of zones.

    Zones do not have to be adjacent. They can even be separate buildings.
    """
    def __init__(self, name: str | None = None, uid: str | None = None):
        """Initialize the building.

        Args:
            name: name of the building
            uid: unique id of the building, random if None
        """
        if name is None:
            name = random_id()
        self.name = validate_name(name)
        if uid is not None:
            self.uid = uid
        else:
            self.uid = random_id()
        self.zones: dict[str, Zone] = {}  # {Zone.name: Zone}
        self.mesh = mesh.Mesh()

    def add_zone(self, zone: Zone) -> None:
        """Add a Zone instance."""
        self.zones[zone.name] = zone

    def get_zone_names(self) -> list[str]:
        """Get list of zone names."""
        return list(self.zones.keys())

    def get_zones(self) -> list[Zone]:
        """Get list of zones."""
        return list(self.zones.values())

    # TODO: Below function could be split across all levels (Zone/Solid/Wall/Polygon)
    def get_object(self, path: str) -> Zone | Solid | Wall | Polygon:
        """Get object by the path. The path contains names of nested components."""
        names = path.split("/")

        zone_name = None
        solid_name = None
        wall_name = None
        poly_name = None

        i = 0
        while len(names) > 0:
            n = names.pop(0)
            if i == 0:
                zone_name = n
            elif i == 1:
                solid_name = n
            elif i == 2:
                wall_name = n
            elif i == 3:
                poly_name = n
            else:
                raise ValueError(f"Name too long, too many slashes: {path}")
            i += 1

        if zone_name is not None:
            matching_zones = [z for z in self.get_zones() if z.name == zone_name]
            if len(matching_zones) == 0:
                raise ValueError(f"Zone not found {zone_name}")
            elif len(matching_zones) > 1:
                raise ValueError(f"Zone not unique {zone_name}")
            zone = matching_zones[0]
        else:
            zone = None

        if solid_name is not None and zone is not None:
            matching_solids = [s for s in zone.get_solids() if s.name == solid_name]
            if len(matching_solids) == 0:
                raise ValueError(f"Solid not found {solid_name}")
            elif len(matching_solids) > 1:
                raise ValueError(f"Solid not unique {solid_name}")
            solid = matching_solids[0]
        else:
            solid = None

        if wall_name is not None and solid is not None:
            matching_walls = [w for w in solid.get_walls() if w.name == wall_name]
            if len(matching_walls) == 0:
                raise ValueError(f"Wall not found {wall_name}")
            elif len(matching_walls) > 1:
                raise ValueError(f"Wall not unique {wall_name}")
            wall = matching_walls[0]
        else:
            wall = None

        if poly_name is not None and wall is not None:
            matching_polys = [p for p in wall.get_polygons(children=True) if p.name == poly_name]
            if len(matching_polys) == 0:
                raise ValueError(f"Polygon not found {poly_name}")
            elif len(matching_polys) > 1:
                raise ValueError(f"Polygon not unique {poly_name}")
            poly = matching_polys[0]
        else:
            poly = None

        return_queue = [
            (poly_name, poly),
            (wall_name, wall),
            (solid_name, solid),
            (zone_name, zone),
        ]

        for name, obj in return_queue:
            if name is None:
                continue
            else:
                return obj

        raise ValueError(f"Object not found: {path}")

    def volume(self) -> float:
        """Calculate building volume as the sum of zone volumes."""
        volume = 0.0
        for z in self.zones.values():
            volume += z.volume()
        return volume

    def get_mesh(
        self,
        children: bool = True,
    ) -> tuple[list[Point], list[tuple[int, ...]]]:
        """Get vertices and faces of this building's polygons.

        This function returns faces generated by the ear-clipping algorithm.

        Args:
            children: if True, will include subpolygons

        Return:
            tuple of vertices and faces
        """
        verts = []
        faces = []

        for z in self.zones.values():
            offset = len(verts)
            v, f = z.get_mesh(children)
            verts.extend(v)
            f = np.array(f) + offset
            f = [tuple(x) for x in f]
            faces.extend(f)

        return verts, faces

    def generate_simulation_mesh(
        self,
        delta: float | None = None,
        include_volumes: bool = False,
    ) -> None:
        """Generate mesh suitable for numerical simulations.

        Generates surface mesh by default (`PolyMesh`).
        If `include_volumes` is `True`, generates also the volume mesh (`SolidMesh`).

        Args:
            delta: approximate element size, will use default is `None`
            include_volumes: if True, will generate surface and volume meshes
        """
        if delta is None:
            delta = MESH_DELTA

        self.mesh = mesh.Mesh(delta=delta)

        for zone in self.get_zones():
            self.mesh.add_zone(zone)

        self.mesh.generate(solidmesh=include_volumes)
